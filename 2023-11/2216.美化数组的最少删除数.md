# 2216.美化数组的最少删除数

2023.11.21



给你一个下标从 **0** 开始的整数数组 `nums` ，如果满足下述条件，则认为数组 `nums` 是一个 **美丽数组** ：

- `nums.length` 为偶数
- 对所有满足 `i % 2 == 0` 的下标 `i` ，`nums[i] != nums[i + 1]` 均成立

注意，空数组同样认为是美丽数组。

你可以从 `nums` 中删除任意数量的元素。当你删除一个元素时，被删除元素右侧的所有元素将会向左移动一个单位以填补空缺，而左侧的元素将会保持 **不变** 。

返回使 `nums` 变为美丽数组所需删除的 **最少** 元素数目。

**示例 1：**

```
输入：nums = [1,1,2,3,5]
输出：1
解释：可以删除 nums[0] 或 nums[1] ，这样得到的 nums = [1,2,3,5] 是一个美丽数组。可以证明，要想使 nums 变为美丽数组，至少需要删除 1 个元素。
```

**示例 2：**

```
输入：nums = [1,1,2,2,3,3]
输出：2
解释：可以删除 nums[0] 和 nums[5] ，这样得到的 nums = [1,2,2,3] 是一个美丽数组。可以证明，要想使 nums 变为美丽数组，至少需要删除 2 个元素。
```

**提示：**

- `1 <= nums.length <= 105`
- `0 <= nums[i] <= 105`







没想到这题一次直接过了

对于连续相同的数，我们只考虑第一个数下标为偶数，若为奇数下标且它与右边的数相同，也是美丽数组，不用考虑。在将偶数坐标 i 后面的相同元素全部删除后，下一个元素与该偶数坐标元素必不相同，直接考虑第 i + 2 个元素即新的偶数位即可。

需要注意的是，美丽数组的长度必须是偶数，若原数组长度 l 为奇数，在最后需要删掉末尾最后一个元素。

时间复杂度O(n)

```c++
class Solution {
public:
    int minDeletion(vector<int>& nums) {
        int re = 0, i, l = nums.size();
        for(i = 0; i < l; i += 2)
            while(i + 1 < l && nums[i] == nums[i + 1])
            {
                re++;
                i++;
            }
        if(i > l)
            re += l - (i - 2);
        return re;
    }
};
```

